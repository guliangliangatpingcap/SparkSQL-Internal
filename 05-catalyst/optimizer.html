
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Optimizer · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="overall.html" />
    
    
    <link rel="prev" href="analyzer.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../01-introduction/">
            
                <a href="../01-introduction/">
            
                    
                    SparkSQL介绍
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../01-introduction/history.html">
            
                <a href="../01-introduction/history.html">
            
                    
                    SparkSQL的发展历程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../01-introduction/performance.html">
            
                <a href="../01-introduction/performance.html">
            
                    
                    SparkSQL的性能
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../02-use_of_sparksql/">
            
                <a href="../02-use_of_sparksql/">
            
                    
                    SparkSQL的使用
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../02-use_of_sparksql/sqlcontext.html">
            
                <a href="../02-use_of_sparksql/sqlcontext.html">
            
                    
                    SqlContext的使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../02-use_of_sparksql/hivecontext.html">
            
                <a href="../02-use_of_sparksql/hivecontext.html">
            
                    
                    HiveContext的使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../02-use_of_sparksql/usage.html">
            
                <a href="../02-use_of_sparksql/usage.html">
            
                    
                    SparkSQL的三种使用方式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../02-use_of_sparksql/common_operation.html">
            
                <a href="../02-use_of_sparksql/common_operation.html">
            
                    
                    常用操作
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../02-use_of_sparksql/cache.html">
            
                <a href="../02-use_of_sparksql/cache.html">
            
                    
                    Cache Table
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../02-use_of_sparksql/external_data_source.html">
            
                <a href="../02-use_of_sparksql/external_data_source.html">
            
                    
                    外部数据源
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../03-performance-turning/">
            
                <a href="../03-performance-turning/">
            
                    
                    SparkSQL调优
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../04-context/">
            
                <a href="../04-context/">
            
                    
                    SparkSQL的运行过程
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../04-context/sqlcontext.html">
            
                <a href="../04-context/sqlcontext.html">
            
                    
                    SqlContext的运行过程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../04-context/hivecontext.html">
            
                <a href="../04-context/hivecontext.html">
            
                    
                    HiveContext的运行过程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="./">
            
                <a href="./">
            
                    
                    Catalyst优化器
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="introduction.html">
            
                <a href="introduction.html">
            
                    
                    Catalyst介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="tree_node.html">
            
                <a href="tree_node.html">
            
                    
                    TreeNode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="rule.html">
            
                <a href="rule.html">
            
                    
                    Rule
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="analyzer.html">
            
                <a href="analyzer.html">
            
                    
                    Analyzer
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.6.5" data-path="optimizer.html">
            
                <a href="optimizer.html">
            
                    
                    Optimizer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="overall.html">
            
                <a href="overall.html">
            
                    
                    总结
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../06-component/">
            
                <a href="../06-component/">
            
                    
                    SparkSQL组件解析
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../06-component/sqlparser.html">
            
                <a href="../06-component/sqlparser.html">
            
                    
                    SqlParser
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../06-component/physical_plan.html">
            
                <a href="../06-component/physical_plan.html">
            
                    
                    Physical Plan
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../06-component/udf.html">
            
                <a href="../06-component/udf.html">
            
                    
                    UDF
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../06-component/in-memory_columnar_storage.html">
            
                <a href="../06-component/in-memory_columnar_storage.html">
            
                    
                    In-Memory Columnar Storage
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../06-component/external_data_source.html">
            
                <a href="../06-component/external_data_source.html">
            
                    
                    External Data Source
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../06-component/code_generation.html">
            
                <a href="../06-component/code_generation.html">
            
                    
                    Code Generation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../07-overall/">
            
                <a href="../07-overall/">
            
                    
                    推荐资料
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Optimizer</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="optimizer">Optimizer</h1>
<p>Optimizer&#x7684;&#x4E3B;&#x8981;&#x804C;&#x8D23;&#x662F;&#x5C06;Analyzer&#x8F93;&#x51FA;&#x7684;Resolved Logical Plan&#x6839;&#x636E;&#x4E0D;&#x540C;&#x7684;&#x4F18;&#x5316;&#x7B56;&#x7565;Batch&#xFF0C;&#x6765;&#x5BF9;&#x8BED;&#x6CD5;&#x6811;&#x8FDB;&#x884C;&#x4F18;&#x5316;&#x3002;Optimizer&#x7684;&#x5DE5;&#x4F5C;&#x65B9;&#x5F0F;&#x5176;&#x5B9E;&#x7C7B;&#x4F3C;Analyzer&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x90FD;&#x7EE7;&#x627F;&#x81EA;RuleExecutor[LogicalPlan]&#xFF0C;&#x90FD;&#x662F;&#x6267;&#x884C;&#x4E00;&#x7CFB;&#x5217;&#x7684;Batch&#x64CD;&#x4F5C;&#x3002;</p>
<h3 id="rules&#x4ECB;&#x7ECD;">Rules&#x4ECB;&#x7ECD;</h3>
<p>Optimizer&#x91CC;&#x7684;batches&#x5305;&#x542B;&#x4E86;4&#x5927;&#x7C7B;&#x4F18;&#x5316;&#x7B56;&#x7565;&#xFF1A;</p>
<ol>
<li>Combine Limits&#xFF1A; &#x5408;&#x5E76;Limits</li>
<li>ConstantFolding&#xFF1A; &#x5E38;&#x91CF;&#x5408;&#x5E76;</li>
<li>Decimal Optimizations&#xFF1A; Decimal&#x7C7B;&#x578B;&#x6570;&#x636E;&#x8BA1;&#x7B97;&#x4F18;&#x5316;</li>
<li>Filter Pushdown&#xFF1A; &#x8FC7;&#x6EE4;&#x5668;&#x4E0B;&#x63A8;</li>
</ol>
<pre><code>object DefaultOptimizer extends Optimizer {
  val batches =
    Batch(&quot;Combine Limits&quot;, FixedPoint(100),
      CombineLimits) ::
    Batch(&quot;ConstantFolding&quot;, FixedPoint(100),
      NullPropagation,
      ConstantFolding,
      LikeSimplification,
      BooleanSimplification,
      SimplifyFilters,
      SimplifyCasts,
      SimplifyCaseConversionExpressions,
      OptimizeIn) ::
    Batch(&quot;Decimal Optimizations&quot;, FixedPoint(100),
      DecimalAggregates) ::
    Batch(&quot;Filter Pushdown&quot;, FixedPoint(100),
      UnionPushdown,
      CombineFilters,
      PushPredicateThroughProject,
      PushPredicateThroughJoin,
      ColumnPruning) :: Nil
}
</code></pre><h5 id="combinelimits">CombineLimits</h5>
<p>&#x76EE;&#x524D;&#x8BE5;&#x89C4;&#x5219;&#x65E0;&#x6CD5;&#x4F18;&#x5316;<code>val query = sql(&quot;select * from (select * from table limit 100) limit 10 &quot;)</code>&#x8FD9;&#x6837;&#x7684;&#x8BED;&#x53E5;&#xFF0C;&#x56E0;&#x4E3A;CombineLimits&#x5728;&#x7B2C;&#x4E00;&#x4E2A;batch&#x91CC;&#x9762;&#xFF0C;&#x800C;&#x4E14;&#x662F;&#x552F;&#x4E00;&#x4E00;&#x4E2A;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#x5B83;&#x4E0D;&#x80FD;&#x5728;&#x5176;&#x4ED6;&#x89C4;&#x5219;&#x7684;&#x57FA;&#x7840;&#x4E0A;&#x518D;&#x8FD0;&#x884C;&#x81EA;&#x5DF1;&#xFF0C;&#x800C;&#x53EA;&#x80FD;&#x4F18;&#x5316;&#x8FDE;&#x7EED;&#x51FA;&#x73B0;&#x7684;&#x4E24;&#x4E2A;Limit&#x3002;</p>
<pre><code>/**
 * Combines two adjacent [[Limit]] operators into one, merging the
 * expressions into one single expression.
 */
object CombineLimits extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case ll @ Limit(le, nl @ Limit(ne, grandChild)) =&gt;
      Limit(If(LessThan(ne, le), ne, le), grandChild)
  }
}
</code></pre><h5 id="nullpropagation">NullPropagation</h5>
<p>Literal&#x5B57;&#x9762;&#x91CF;&#x662F;&#x4E00;&#x4E2A;&#x80FD;&#x5339;&#x914D;&#x4EFB;&#x610F;&#x57FA;&#x672C;&#x7C7B;&#x578B;&#x7684;&#x7C7B;&#x3002;</p>
<pre><code>object Literal {
  def apply(v: Any): Literal = v match {
    case i: Int =&gt; Literal(i, IntegerType)
    case l: Long =&gt; Literal(l, LongType)
    case d: Double =&gt; Literal(d, DoubleType)
    case f: Float =&gt; Literal(f, FloatType)
    case b: Byte =&gt; Literal(b, ByteType)
    case s: Short =&gt; Literal(s, ShortType)
    case s: String =&gt; Literal(s, StringType)
    case b: Boolean =&gt; Literal(b, BooleanType)
    case d: BigDecimal =&gt; Literal(Decimal(d), DecimalType.Unlimited)
    case d: Decimal =&gt; Literal(d, DecimalType.Unlimited)
    case t: Timestamp =&gt; Literal(t, TimestampType)
    case d: Date =&gt; Literal(d, DateType)
    case a: Array[Byte] =&gt; Literal(a, BinaryType)
    case null =&gt; Literal(null, NullType)
  }
}
</code></pre><p>&#x6CE8;&#x610F;Literal&#x662F;&#x4E00;&#x4E2A;LeafExpression&#xFF0C;&#x6838;&#x5FC3;&#x65B9;&#x6CD5;&#x662F;eval&#xFF0C;&#x7ED9;&#x5B9A;Row&#xFF0C;&#x8BA1;&#x7B97;&#x8868;&#x8FBE;&#x5F0F;&#x8FD4;&#x56DE;&#x503C;&#x3002;</p>
<pre><code>case class Literal(value: Any, dataType: DataType) extends LeafExpression {

  override def foldable = true
  def nullable = value == null


  override def toString = if (value != null) value.toString else &quot;null&quot;

  type EvaluatedType = Any
  override def eval(input: Row):Any = value
}
</code></pre><p>NullPropagation&#x662F;&#x4E00;&#x4E2A;&#x80FD;&#x5C06;Expression Expressions&#x66FF;&#x6362;&#x4E3A;&#x7B49;&#x4EF7;&#x7684;Literal&#x503C;&#x7684;&#x4F18;&#x5316;&#xFF0C;&#x5E76;&#x4E14;&#x80FD;&#x591F;&#x907F;&#x514D;NULL&#x503C;&#x5728;SQL&#x8BED;&#x6CD5;&#x6811;&#x7684;&#x4F20;&#x64AD;&#x3002;</p>
<pre><code>/**
 * Replaces [[Expression Expressions]] that can be statically evaluated with
 * equivalent [[Literal]] values. This rule is more specific with
 * Null value propagation from bottom to top of the expression tree.
 */
object NullPropagation extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case q: LogicalPlan =&gt; q transformExpressionsUp {
      case e @ Count(Literal(null, _)) =&gt; Cast(Literal(0L), e.dataType)
      case e @ Sum(Literal(c, _)) if c == 0 =&gt; Cast(Literal(0L), e.dataType)
      case e @ Average(Literal(c, _)) if c == 0 =&gt; Literal(0.0, e.dataType)
      case e @ IsNull(c) if !c.nullable =&gt; Literal(false, BooleanType)
      case e @ IsNotNull(c) if !c.nullable =&gt; Literal(true, BooleanType)
      case e @ GetItem(Literal(null, _), _) =&gt; Literal(null, e.dataType)
      case e @ GetItem(_, Literal(null, _)) =&gt; Literal(null, e.dataType)
      case e @ GetField(Literal(null, _), _) =&gt; Literal(null, e.dataType)
      case e @ EqualNullSafe(Literal(null, _), r) =&gt; IsNull(r)
      case e @ EqualNullSafe(l, Literal(null, _)) =&gt; IsNull(l)

      // For Coalesce, remove null literals.
      case e @ Coalesce(children) =&gt;
        val newChildren = children.filter {
          case Literal(null, _) =&gt; false
          case _ =&gt; true
        }
        if (newChildren.length == 0) {
          Literal(null, e.dataType)
        } else if (newChildren.length == 1) {
          newChildren(0)
        } else {
          Coalesce(newChildren)
        }

      case e @ Substring(Literal(null, _), _, _) =&gt; Literal(null, e.dataType)
      case e @ Substring(_, Literal(null, _), _) =&gt; Literal(null, e.dataType)
      case e @ Substring(_, _, Literal(null, _)) =&gt; Literal(null, e.dataType)

      // Put exceptional cases above if any
      case e: BinaryArithmetic =&gt; e.children match {
        case Literal(null, _) :: right :: Nil =&gt; Literal(null, e.dataType)
        case left :: Literal(null, _) :: Nil =&gt; Literal(null, e.dataType)
        case _ =&gt; e
      }
      case e: BinaryComparison =&gt; e.children match {
        case Literal(null, _) :: right :: Nil =&gt; Literal(null, e.dataType)
        case left :: Literal(null, _) :: Nil =&gt; Literal(null, e.dataType)
        case _ =&gt; e
      }
      case e: StringRegexExpression =&gt; e.children match {
        case Literal(null, _) :: right :: Nil =&gt; Literal(null, e.dataType)
        case left :: Literal(null, _) :: Nil =&gt; Literal(null, e.dataType)
        case _ =&gt; e
      }
      case e: StringComparison =&gt; e.children match {
        case Literal(null, _) :: right :: Nil =&gt; Literal(null, e.dataType)
        case left :: Literal(null, _) :: Nil =&gt; Literal(null, e.dataType)
        case _ =&gt; e
      }
    }
  }
}
</code></pre><h5 id="constantfolding">ConstantFolding</h5>
<p>&#x5E38;&#x91CF;&#x5408;&#x5E76;&#x662F;&#x5C5E;&#x4E8E;Expression&#x4F18;&#x5316;&#x7684;&#x4E00;&#x79CD;&#xFF0C;&#x5BF9;&#x4E8E;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x8BA1;&#x7B97;&#x7684;&#x5E38;&#x91CF;&#xFF0C;&#x4E0D;&#x7528;&#x653E;&#x5230;&#x7269;&#x7406;&#x6267;&#x884C;&#x91CC;&#x53BB;&#x751F;&#x6210;&#x5BF9;&#x8C61;&#x6765;&#x8BA1;&#x7B97;&#x4E86;&#xFF0C;&#x76F4;&#x63A5;&#x53EF;&#x4EE5;&#x5728;&#x8BA1;&#x5212;&#x91CC;&#x5C31;&#x8BA1;&#x7B97;&#x51FA;&#x6765;&#x3002;</p>
<pre><code>/**
 * Replaces [[Expression Expressions]] that can be statically evaluated with
 * equivalent [[Literal]] values.
 */
object ConstantFolding extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case q: LogicalPlan =&gt; q transformExpressionsDown {
      // Skip redundant folding of literals. This rule is technically not necessary. Placing this
      // here avoids running the next rule for Literal values, which would create a new Literal
      // object and running eval unnecessarily.
      case l: Literal =&gt; l

      // Fold expressions that are foldable.
      case e if e.foldable =&gt; Literal(e.eval(null), e.dataType)

      // Fold &quot;literal in (item1, item2, ..., literal, ...)&quot; into true directly.
      case In(Literal(v, _), list) if list.exists {
          case Literal(candidate, _) if candidate == v =&gt; true
          case _ =&gt; false
        } =&gt; Literal(true, BooleanType)
    }
  }
}
</code></pre><h5 id="likesimplification">LikeSimplification</h5>
<p>&#x7B80;&#x5316;Like&#x5B57;&#x53E5;&#xFF0C;&#x5982;&#x679C;&#x7B26;&#x5408;&#x4E0B;&#x9762;&#x56DB;&#x79CD;&#x60C5;&#x51B5;&#x4E4B;&#x4E00;&#xFF1A;</p>
<ol>
<li>startsWith</li>
<li>endsWith</li>
<li>contains</li>
<li>equalTo</li>
</ol>
<pre><code>/**
 * Simplifies LIKE expressions that do not need full regular expressions to evaluate the condition.
 * For example, when the expression is just checking to see if a string starts with a given
 * pattern.
 */
object LikeSimplification extends Rule[LogicalPlan] {
  // if guards below protect from escapes on trailing %.
  // Cases like &quot;something\%&quot; are not optimized, but this does not affect correctness.
  val startsWith = &quot;([^_%]+)%&quot;.r
  val endsWith = &quot;%([^_%]+)&quot;.r
  val contains = &quot;%([^_%]+)%&quot;.r
  val equalTo = &quot;([^_%]*)&quot;.r

  def apply(plan: LogicalPlan): LogicalPlan = plan transformAllExpressions {
    case Like(l, Literal(startsWith(pattern), StringType)) if !pattern.endsWith(&quot;\\&quot;) =&gt;
      StartsWith(l, Literal(pattern))
    case Like(l, Literal(endsWith(pattern), StringType)) =&gt;
      EndsWith(l, Literal(pattern))
    case Like(l, Literal(contains(pattern), StringType)) if !pattern.endsWith(&quot;\\&quot;) =&gt;
      Contains(l, Literal(pattern))
    case Like(l, Literal(equalTo(pattern), StringType)) =&gt;
      EqualTo(l, Literal(pattern))
  }
}
</code></pre><h5 id="booleansimplification">BooleanSimplification</h5>
<p>&#x8FD9;&#x4E2A;&#x662F;&#x5BF9;&#x5E03;&#x5C14;&#x8868;&#x8FBE;&#x5F0F;&#x7684;&#x4F18;&#x5316;&#xFF0C;&#x6709;&#x70B9;&#x50CF;java&#x5E03;&#x5C14;&#x8868;&#x8FBE;&#x5F0F;&#x4E2D;&#x7684;&#x77ED;&#x8DEF;&#x5224;&#x65AD;&#x3002;&#x770B;&#x770B;&#x5E03;&#x5C14;&#x8868;&#x8FBE;&#x5F0F;2&#x8FB9;&#x80FD;&#x4E0D;&#x80FD;&#x901A;&#x8FC7;&#x53EA;&#x8BA1;&#x7B97;1&#x8FB9;&#xFF0C;&#x800C;&#x7701;&#x53BB;&#x8BA1;&#x7B97;&#x53E6;&#x4E00;&#x8FB9;&#x800C;&#x63D0;&#x9AD8;&#x6548;&#x7387;&#xFF0C;&#x79F0;&#x4E3A;&#x7B80;&#x5316;&#x5E03;&#x5C14;&#x8868;&#x8FBE;&#x5F0F;&#x3002;</p>
<pre><code>/**
 * Simplifies boolean expressions where the answer can be determined without evaluating both sides.
 * Note that this rule can eliminate expressions that might otherwise have been evaluated and thus
 * is only safe when evaluations of expressions does not result in side effects.
 */
object BooleanSimplification extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case q: LogicalPlan =&gt; q transformExpressionsUp {
      case and @ And(left, right) =&gt;
        (left, right) match {
          case (Literal(true, BooleanType), r) =&gt; r
          case (l, Literal(true, BooleanType)) =&gt; l
          case (Literal(false, BooleanType), _) =&gt; Literal(false)
          case (_, Literal(false, BooleanType)) =&gt; Literal(false)
          case (_, _) =&gt; and
        }

      case or @ Or(left, right) =&gt;
        (left, right) match {
          case (Literal(true, BooleanType), _) =&gt; Literal(true)
          case (_, Literal(true, BooleanType)) =&gt; Literal(true)
          case (Literal(false, BooleanType), r) =&gt; r
          case (l, Literal(false, BooleanType)) =&gt; l
          case (_, _) =&gt; or
        }

      case not @ Not(exp) =&gt;
        exp match {
          case Literal(true, BooleanType) =&gt; Literal(false)
          case Literal(false, BooleanType) =&gt; Literal(true)
          case GreaterThan(l, r) =&gt; LessThanOrEqual(l, r)
          case GreaterThanOrEqual(l, r) =&gt; LessThan(l, r)
          case LessThan(l, r) =&gt; GreaterThanOrEqual(l, r)
          case LessThanOrEqual(l, r) =&gt; GreaterThan(l, r)
          case Not(e) =&gt; e
          case _ =&gt; not
        }

      // Turn &quot;if (true) a else b&quot; into &quot;a&quot;, and if (false) a else b&quot; into &quot;b&quot;.
      case e @ If(Literal(v, _), trueValue, falseValue) =&gt; if (v == true) trueValue else falseValue
    }
  }
}
</code></pre><h5 id="simplifyfilters">SimplifyFilters</h5>
<p>&#x5982;&#x679C;filter&#x603B;&#x662F;&#x8FD4;&#x56DE;true&#xFF0C;&#x5219;&#x5220;&#x9664;filter&#x8FD4;&#x56DE;child&#xFF0C;&#x5982;&#x679C;filter&#x603B;&#x662F;&#x8FD4;&#x56DE;false&#xFF0C;&#x5219;&#x8FD4;&#x56DE;empty&#x7684;relation&#x3002;</p>
<pre><code>/**
 * Removes filters that can be evaluated trivially.  This is done either by eliding the filter for
 * cases where it will always evaluate to `true`, or substituting a dummy empty relation when the
 * filter will always evaluate to `false`.
 */
object SimplifyFilters extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    // If the filter condition always evaluate to true, remove the filter.
    case Filter(Literal(true, BooleanType), child) =&gt; child
    // If the filter condition always evaluate to null or false,
    // replace the input with an empty relation.
    case Filter(Literal(null, _), child) =&gt; LocalRelation(child.output, data = Seq.empty)
    case Filter(Literal(false, BooleanType), child) =&gt; LocalRelation(child.output, data = Seq.empty)
  }
}
</code></pre><h5 id="simplifycasts">SimplifyCasts</h5>
<p>&#x5982;&#x679C;Cast&#x7684;&#x7C7B;&#x578B;&#x548C;&#x5B9E;&#x9645;&#x7C7B;&#x578B;&#x4E00;&#x81F4;&#xFF0C;&#x5219;&#x53BB;&#x9664;&#x6CA1;&#x5FC5;&#x8981;&#x7684;cast&#x3002;</p>
<pre><code>/**
 * Removes [[Cast Casts]] that are unnecessary because the input is already the correct type.
 */
object SimplifyCasts extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transformAllExpressions {
    case Cast(e, dataType) if e.dataType == dataType =&gt; e
  }
}
</code></pre><h5 id="simplifycaseconversionexpressions">SimplifyCaseConversionExpressions</h5>
<p>&#x53BB;&#x9664;&#x5185;&#x5C42;&#x6CA1;&#x5FC5;&#x8981;&#x7684;&#x5927;&#x5C0F;&#x5199;&#x8F6C;&#x6362;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x5916;&#x5C42;&#x7684;&#x8F6C;&#x6362;&#x3002;</p>
<pre><code>/**
 * Removes the inner [[CaseConversionExpression]] that are unnecessary because
 * the inner conversion is overwritten by the outer one.
 */
object SimplifyCaseConversionExpressions extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case q: LogicalPlan =&gt; q transformExpressionsUp {
      case Upper(Upper(child)) =&gt; Upper(child)
      case Upper(Lower(child)) =&gt; Upper(child)
      case Lower(Upper(child)) =&gt; Lower(child)
      case Lower(Lower(child)) =&gt; Lower(child)
    }
  }
}
</code></pre><h5 id="optimizein">OptimizeIn</h5>
<p>&#x5C06;In(value, Seq[Literal])&#x7684;&#x8282;&#x70B9;&#x8F6C;&#x6362;&#x4E3A;&#x7B49;&#x4EF7;&#x7684;InSet(value, HashSet[Literal])&#xFF0C;&#x4F1A;&#x5FEB;&#x5F88;&#x591A;&#x3002;</p>
<pre><code>/**
 * Replaces [[In (value, seq[Literal])]] with optimized version[[InSet (value, HashSet[Literal])]]
 * which is much faster
 */
object OptimizeIn extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case q: LogicalPlan =&gt; q transformExpressionsDown {
      case In(v, list) if !list.exists(!_.isInstanceOf[Literal]) =&gt;
          val hSet = list.map(e =&gt; e.eval(null))
          InSet(v, HashSet() ++ hSet)
    }
  }
}
</code></pre><h5 id="decimalaggregates">DecimalAggregates</h5>
<p>&#x8BA1;&#x7B97;fixed-precision Decimal&#x7C7B;&#x578B;&#x7684;sum&#x548C;avg&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5148;&#x628A;&#x5B83;&#x8F6C;&#x6362;&#x4E3A;Long&#x7C7B;&#x578B;&#xFF0C;&#x505A;&#x8BA1;&#x7B97;&#xFF0C;&#x6700;&#x540E;&#x5728;&#x8F6C;&#x5316;&#x4E3A;Decimal&#xFF0C;&#x4F1A;&#x6BD4;&#x8F83;&#x5FEB;&#x3002;</p>
<pre><code>/**
 * Speeds up aggregates on fixed-precision decimals by executing them on unscaled Long values.
 *
 * This uses the same rules for increasing the precision and scale of the output as
 * [[org.apache.spark.sql.catalyst.analysis.HiveTypeCoercion.DecimalPrecision]].
 */
object DecimalAggregates extends Rule[LogicalPlan] {
  import Decimal.MAX_LONG_DIGITS

  /** Maximum number of decimal digits representable precisely in a Double */
  val MAX_DOUBLE_DIGITS = 15

  def apply(plan: LogicalPlan): LogicalPlan = plan transformAllExpressions {
    case Sum(e @ DecimalType.Expression(prec, scale)) if prec + 10 &lt;= MAX_LONG_DIGITS =&gt;
      MakeDecimal(Sum(UnscaledValue(e)), prec + 10, scale)

    case Average(e @ DecimalType.Expression(prec, scale)) if prec + 4 &lt;= MAX_DOUBLE_DIGITS =&gt;
      Cast(
        Divide(Average(UnscaledValue(e)), Literal(math.pow(10.0, scale), DoubleType)),
        DecimalType(prec + 4, scale + 4))
  }
}
</code></pre><h5 id="unionpushdown">UnionPushdown</h5>
<p>&#x628A;filter&#x548C;project pushdown&#x5230;union&#x4E0B;&#x9762;&#x3002;</p>
<pre><code>/**
  *  Pushes operations to either side of a Union.
  */
object UnionPushdown extends Rule[LogicalPlan] {

  /**
    *  Maps Attributes from the left side to the corresponding Attribute on the right side.
    */
  def buildRewrites(union: Union): AttributeMap[Attribute] = {
    assert(union.left.output.size == union.right.output.size)

    AttributeMap(union.left.output.zip(union.right.output))
  }

  /**
    *  Rewrites an expression so that it can be pushed to the right side of a Union operator.
    *  This method relies on the fact that the output attributes of a union are always equal
    *  to the left child&apos;s output.
    */
  def pushToRight[A &lt;: Expression](e: A, rewrites: AttributeMap[Attribute]): A = {
    val result = e transform {
      case a: Attribute =&gt; rewrites(a)
    }

    // We must promise the compiler that we did not discard the names in the case of project
    // expressions.  This is safe since the only transformation is from Attribute =&gt; Attribute.
    result.asInstanceOf[A]
  }

  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    // Push down filter into union
    case Filter(condition, u @ Union(left, right)) =&gt;
      val rewrites = buildRewrites(u)
      Union(
        Filter(condition, left),
        Filter(pushToRight(condition, rewrites), right))

    // Push down projection into union
    case Project(projectList, u @ Union(left, right)) =&gt;
      val rewrites = buildRewrites(u)
      Union(
        Project(projectList, left),
        Project(projectList.map(pushToRight(_, rewrites)), right))
  }
}
</code></pre><h5 id="combinefilters">CombineFilters</h5>
<p>&#x5408;&#x5E76;&#x4E24;&#x4E2A;&#x76F8;&#x90BB;&#x7684;Filter,&#x8FD9;&#x4E2A;&#x548C;&#x4E0A;&#x8FF0;Combine Limit&#x5DEE;&#x4E0D;&#x591A;&#x3002;&#x5408;&#x5E76;2&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x51CF;&#x5C11;&#x6811;&#x7684;&#x6DF1;&#x5EA6;&#x4ECE;&#x800C;&#x51CF;&#x5C11;&#x91CD;&#x590D;&#x6267;&#x884C;&#x8FC7;&#x6EE4;&#x7684;&#x4EE3;&#x4EF7;&#x3002;</p>
<pre><code>/**
 * Combines two adjacent [[Filter]] operators into one, merging the
 * conditions into one conjunctive predicate.
 */
object CombineFilters extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case ff @ Filter(fc, nf @ Filter(nc, grandChild)) =&gt; Filter(And(nc, fc), grandChild)
  }
}
</code></pre><h5 id="pushpredicatethroughproject">PushPredicateThroughProject</h5>
<p>Predict push&#x5230;project&#x4E0B;&#x9762;&#xFF0C;&#x5982;&#x679C;predict&#x4E0D;&#x4F9D;&#x8D56;&#x4E8E;project&#x3002;</p>
<pre><code>/**
 * Pushes [[Filter]] operators through [[Project]] operators, in-lining any [[Alias Aliases]]
 * that were defined in the projection.
 *
 * This heuristic is valid assuming the expression evaluation cost is minimal.
 */
object PushPredicateThroughProject extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    case filter @ Filter(condition, project @ Project(fields, grandChild)) =&gt;
      val sourceAliases = fields.collect { case a @ Alias(c, _) =&gt;
        (a.toAttribute: Attribute) -&gt; c
      }.toMap
      project.copy(child = filter.copy(
        replaceAlias(condition, sourceAliases),
        grandChild))
  }

  def replaceAlias(condition: Expression, sourceAliases: Map[Attribute, Expression]): Expression = {
    condition transform {
      case a: AttributeReference =&gt; sourceAliases.getOrElse(a, a)
    }
  }
}
</code></pre><h5 id="pushpredicatethroughjoin">PushPredicateThroughJoin</h5>
<p>Predict push&#x5230;project&#x4E0B;&#x9762;&#xFF0C;&#x5982;&#x679C;predict&#x4E0D;&#x4F9D;&#x8D56;&#x4E8E;join&#x3002;</p>
<pre><code>/**
 * Pushes down [[Filter]] operators where the `condition` can be
 * evaluated using only the attributes of the left or right side of a join.  Other
 * [[Filter]] conditions are moved into the `condition` of the [[Join]].
 *
 * And also Pushes down the join filter, where the `condition` can be evaluated using only the
 * attributes of the left or right side of sub query when applicable.
 *
 * Check https://cwiki.apache.org/confluence/display/Hive/OuterJoinBehavior for more details
 */
object PushPredicateThroughJoin extends Rule[LogicalPlan] with PredicateHelper {
  /**
   * Splits join condition expressions into three categories based on the attributes required
   * to evaluate them.
   * @return (canEvaluateInLeft, canEvaluateInRight, haveToEvaluateInBoth)
   */
  private def split(condition: Seq[Expression], left: LogicalPlan, right: LogicalPlan) = {
    val (leftEvaluateCondition, rest) =
        condition.partition(_.references subsetOf left.outputSet)
    val (rightEvaluateCondition, commonCondition) =
        rest.partition(_.references subsetOf right.outputSet)

    (leftEvaluateCondition, rightEvaluateCondition, commonCondition)
  }

  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    // push the where condition down into join filter
    case f @ Filter(filterCondition, Join(left, right, joinType, joinCondition)) =&gt;
      val (leftFilterConditions, rightFilterConditions, commonFilterCondition) =
        split(splitConjunctivePredicates(filterCondition), left, right)

      joinType match {
        case Inner =&gt;
          // push down the single side `where` condition into respective sides
          val newLeft = leftFilterConditions.
            reduceLeftOption(And).map(Filter(_, left)).getOrElse(left)
          val newRight = rightFilterConditions.
            reduceLeftOption(And).map(Filter(_, right)).getOrElse(right)
          val newJoinCond = (commonFilterCondition ++ joinCondition).reduceLeftOption(And)

          Join(newLeft, newRight, Inner, newJoinCond)
        case RightOuter =&gt;
          // push down the right side only `where` condition
          val newLeft = left
          val newRight = rightFilterConditions.
            reduceLeftOption(And).map(Filter(_, right)).getOrElse(right)
          val newJoinCond = joinCondition
          val newJoin = Join(newLeft, newRight, RightOuter, newJoinCond)

          (leftFilterConditions ++ commonFilterCondition).
            reduceLeftOption(And).map(Filter(_, newJoin)).getOrElse(newJoin)
        case _ @ (LeftOuter | LeftSemi) =&gt;
          // push down the left side only `where` condition
          val newLeft = leftFilterConditions.
            reduceLeftOption(And).map(Filter(_, left)).getOrElse(left)
          val newRight = right
          val newJoinCond = joinCondition
          val newJoin = Join(newLeft, newRight, joinType, newJoinCond)

          (rightFilterConditions ++ commonFilterCondition).
            reduceLeftOption(And).map(Filter(_, newJoin)).getOrElse(newJoin)
        case FullOuter =&gt; f // DO Nothing for Full Outer Join
      }

    // push down the join filter into sub query scanning if applicable
    case f @ Join(left, right, joinType, joinCondition) =&gt;
      val (leftJoinConditions, rightJoinConditions, commonJoinCondition) =
        split(joinCondition.map(splitConjunctivePredicates).getOrElse(Nil), left, right)

      joinType match {
        case Inner =&gt;
          // push down the single side only join filter for both sides sub queries
          val newLeft = leftJoinConditions.
            reduceLeftOption(And).map(Filter(_, left)).getOrElse(left)
          val newRight = rightJoinConditions.
            reduceLeftOption(And).map(Filter(_, right)).getOrElse(right)
          val newJoinCond = commonJoinCondition.reduceLeftOption(And)

          Join(newLeft, newRight, Inner, newJoinCond)
        case RightOuter =&gt;
          // push down the left side only join filter for left side sub query
          val newLeft = leftJoinConditions.
            reduceLeftOption(And).map(Filter(_, left)).getOrElse(left)
          val newRight = right
          val newJoinCond = (rightJoinConditions ++ commonJoinCondition).reduceLeftOption(And)

          Join(newLeft, newRight, RightOuter, newJoinCond)
        case _ @ (LeftOuter | LeftSemi) =&gt;
          // push down the right side only join filter for right sub query
          val newLeft = left
          val newRight = rightJoinConditions.
            reduceLeftOption(And).map(Filter(_, right)).getOrElse(right)
          val newJoinCond = (leftJoinConditions ++ commonJoinCondition).reduceLeftOption(And)

          Join(newLeft, newRight, joinType, newJoinCond)
        case FullOuter =&gt; f
      }
  }
}
</code></pre><h5 id="columnpruning">ColumnPruning</h5>
<p>&#x5217;&#x88C1;&#x526A;&#x7528;&#x7684;&#x6BD4;&#x8F83;&#x591A;&#xFF0C;&#x5C31;&#x662F;&#x51CF;&#x5C11;&#x4E0D;&#x5FC5;&#x8981;select&#x7684;&#x67D0;&#x4E9B;&#x5217;&#x3002;&#x5217;&#x88C1;&#x526A;&#x5728;3&#x79CD;&#x5730;&#x65B9;&#x53EF;&#x4EE5;&#x7528;&#xFF1A;</p>
<ol>
<li>&#x5728;&#x805A;&#x5408;&#x64CD;&#x4F5C;&#x4E2D;&#xFF0C;&#x53EF;&#x4EE5;&#x505A;&#x5217;&#x88C1;&#x526A;</li>
<li>&#x5728;join&#x64CD;&#x4F5C;&#x4E2D;&#xFF0C;&#x5DE6;&#x53F3;&#x5B69;&#x5B50;&#x53EF;&#x4EE5;&#x505A;&#x5217;&#x88C1;&#x526A;</li>
<li>&#x5408;&#x5E76;&#x76F8;&#x90BB;&#x7684;Project&#x7684;&#x5217;</li>
</ol>
<pre><code>/**
 * Attempts to eliminate the reading of unneeded columns from the query plan using the following
 * transformations:
 *
 *  - Inserting Projections beneath the following operators:
 *   - Aggregate
 *   - Project &lt;- Join
 *   - LeftSemiJoin
 *  - Collapse adjacent projections, performing alias substitution.
 */
object ColumnPruning extends Rule[LogicalPlan] {
  def apply(plan: LogicalPlan): LogicalPlan = plan transform {
    // Eliminate attributes that are not needed to calculate the specified aggregates.
    case a @ Aggregate(_, _, child) if (child.outputSet -- a.references).nonEmpty =&gt;
      a.copy(child = Project(a.references.toSeq, child))

    // Eliminate unneeded attributes from either side of a Join.
    case Project(projectList, Join(left, right, joinType, condition)) =&gt;
      // Collect the list of all references required either above or to evaluate the condition.
      val allReferences: AttributeSet =
        AttributeSet(
          projectList.flatMap(_.references.iterator)) ++
          condition.map(_.references).getOrElse(AttributeSet(Seq.empty))

      /** Applies a projection only when the child is producing unnecessary attributes */
      def pruneJoinChild(c: LogicalPlan) = prunedChild(c, allReferences)

      Project(projectList, Join(pruneJoinChild(left), pruneJoinChild(right), joinType, condition))

    // Eliminate unneeded attributes from right side of a LeftSemiJoin.
    case Join(left, right, LeftSemi, condition) =&gt;
      // Collect the list of all references required to evaluate the condition.
      val allReferences: AttributeSet =
        condition.map(_.references).getOrElse(AttributeSet(Seq.empty))

      Join(left, prunedChild(right, allReferences), LeftSemi, condition)

    // Combine adjacent Projects.
    case Project(projectList1, Project(projectList2, child)) =&gt;
      // Create a map of Aliases to their values from the child projection.
      // e.g., &apos;SELECT ... FROM (SELECT a + b AS c, d ...)&apos; produces Map(c -&gt; Alias(a + b, c)).
      val aliasMap = projectList2.collect {
        case a @ Alias(e, _) =&gt; (a.toAttribute: Expression, a)
      }.toMap

      // Substitute any attributes that are produced by the child projection, so that we safely
      // eliminate it.
      // e.g., &apos;SELECT c + 1 FROM (SELECT a + b AS C ...&apos; produces &apos;SELECT a + b + 1 ...&apos;
      // TODO: Fix TransformBase to avoid the cast below.
      val substitutedProjection = projectList1.map(_.transform {
        case a if aliasMap.contains(a) =&gt; aliasMap(a)
      }).asInstanceOf[Seq[NamedExpression]]

      Project(substitutedProjection, child)

    // Eliminate no-op Projects
    case Project(projectList, child) if child.output == projectList =&gt; child
  }

  /** Applies a projection only when the child is producing unnecessary attributes */
  private def prunedChild(c: LogicalPlan, allReferences: AttributeSet) =
    if ((c.outputSet -- allReferences.filter(c.outputSet.contains)).nonEmpty) {
      Project(allReferences.filter(c.outputSet.contains).toSeq, c)
    } else {
      c
    }
}
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="analyzer.html" class="navigation navigation-prev " aria-label="Previous page: Analyzer">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="overall.html" class="navigation navigation-next " aria-label="Next page: 总结">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Optimizer","level":"1.6.5","depth":2,"next":{"title":"总结","level":"1.6.6","depth":2,"path":"05-catalyst/overall.md","ref":"05-catalyst/overall.md","articles":[]},"previous":{"title":"Analyzer","level":"1.6.4","depth":2,"path":"05-catalyst/analyzer.md","ref":"05-catalyst/analyzer.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"05-catalyst/optimizer.md","mtime":"2019-09-17T02:15:42.260Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-09-17T02:16:38.644Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

